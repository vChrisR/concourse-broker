// This file was generated by counterfeiter
package maxinflightfakes

import (
	"sync"

	"github.com/concourse/atc/db"
	"github.com/concourse/atc/scheduler/maxinflight"
)

type FakeUpdaterDB struct {
	GetRunningBuildsBySerialGroupStub        func(jobName string, serialGroups []string) ([]db.Build, error)
	getRunningBuildsBySerialGroupMutex       sync.RWMutex
	getRunningBuildsBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getRunningBuildsBySerialGroupReturns struct {
		result1 []db.Build
		result2 error
	}
	GetNextPendingBuildBySerialGroupStub        func(jobName string, serialGroups []string) (db.Build, bool, error)
	getNextPendingBuildBySerialGroupMutex       sync.RWMutex
	getNextPendingBuildBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getNextPendingBuildBySerialGroupReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	SetMaxInFlightReachedStub        func(jobName string, reached bool) error
	setMaxInFlightReachedMutex       sync.RWMutex
	setMaxInFlightReachedArgsForCall []struct {
		jobName string
		reached bool
	}
	setMaxInFlightReachedReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUpdaterDB) GetRunningBuildsBySerialGroup(jobName string, serialGroups []string) ([]db.Build, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getRunningBuildsBySerialGroupMutex.Lock()
	fake.getRunningBuildsBySerialGroupArgsForCall = append(fake.getRunningBuildsBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetRunningBuildsBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getRunningBuildsBySerialGroupMutex.Unlock()
	if fake.GetRunningBuildsBySerialGroupStub != nil {
		return fake.GetRunningBuildsBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getRunningBuildsBySerialGroupReturns.result1, fake.getRunningBuildsBySerialGroupReturns.result2
	}
}

func (fake *FakeUpdaterDB) GetRunningBuildsBySerialGroupCallCount() int {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return len(fake.getRunningBuildsBySerialGroupArgsForCall)
}

func (fake *FakeUpdaterDB) GetRunningBuildsBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return fake.getRunningBuildsBySerialGroupArgsForCall[i].jobName, fake.getRunningBuildsBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeUpdaterDB) GetRunningBuildsBySerialGroupReturns(result1 []db.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	fake.getRunningBuildsBySerialGroupReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeUpdaterDB) GetNextPendingBuildBySerialGroup(jobName string, serialGroups []string) (db.Build, bool, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getNextPendingBuildBySerialGroupMutex.Lock()
	fake.getNextPendingBuildBySerialGroupArgsForCall = append(fake.getNextPendingBuildBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetNextPendingBuildBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getNextPendingBuildBySerialGroupMutex.Unlock()
	if fake.GetNextPendingBuildBySerialGroupStub != nil {
		return fake.GetNextPendingBuildBySerialGroupStub(jobName, serialGroups)
	} else {
		return fake.getNextPendingBuildBySerialGroupReturns.result1, fake.getNextPendingBuildBySerialGroupReturns.result2, fake.getNextPendingBuildBySerialGroupReturns.result3
	}
}

func (fake *FakeUpdaterDB) GetNextPendingBuildBySerialGroupCallCount() int {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return len(fake.getNextPendingBuildBySerialGroupArgsForCall)
}

func (fake *FakeUpdaterDB) GetNextPendingBuildBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return fake.getNextPendingBuildBySerialGroupArgsForCall[i].jobName, fake.getNextPendingBuildBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeUpdaterDB) GetNextPendingBuildBySerialGroupReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	fake.getNextPendingBuildBySerialGroupReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeUpdaterDB) SetMaxInFlightReached(jobName string, reached bool) error {
	fake.setMaxInFlightReachedMutex.Lock()
	fake.setMaxInFlightReachedArgsForCall = append(fake.setMaxInFlightReachedArgsForCall, struct {
		jobName string
		reached bool
	}{jobName, reached})
	fake.recordInvocation("SetMaxInFlightReached", []interface{}{jobName, reached})
	fake.setMaxInFlightReachedMutex.Unlock()
	if fake.SetMaxInFlightReachedStub != nil {
		return fake.SetMaxInFlightReachedStub(jobName, reached)
	} else {
		return fake.setMaxInFlightReachedReturns.result1
	}
}

func (fake *FakeUpdaterDB) SetMaxInFlightReachedCallCount() int {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return len(fake.setMaxInFlightReachedArgsForCall)
}

func (fake *FakeUpdaterDB) SetMaxInFlightReachedArgsForCall(i int) (string, bool) {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return fake.setMaxInFlightReachedArgsForCall[i].jobName, fake.setMaxInFlightReachedArgsForCall[i].reached
}

func (fake *FakeUpdaterDB) SetMaxInFlightReachedReturns(result1 error) {
	fake.SetMaxInFlightReachedStub = nil
	fake.setMaxInFlightReachedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdaterDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeUpdaterDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ maxinflight.UpdaterDB = new(FakeUpdaterDB)
